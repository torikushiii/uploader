---
import ProgressBar from "./ProgressBar.astro";
import ErrorMessage from "./ErrorMessage.astro";

import { ALLOWED_FILE_TYPES } from "utils/constants";
---

<div id="dropArea" class="hidden">
    <div class="drop-message">
        <div class="icon">
            <img src="/assets/drag.svg" alt="Drag and drop icon" width="80" height="80">
        </div>
        <p>Drop your files here</p>
    </div>
</div>

<form id="uploadForm" enctype="multipart/form-data">
    <input type="file" name="file" id="fileInput" style="display: none;" accept={ALLOWED_FILE_TYPES.join(",")} multiple>
    <div id="pasteArea">
        <p>Drag and drop files here, or paste an image</p>
        <div id="previewContainer"></div>
    </div>
    <ErrorMessage id="fileError" />
    <button type="submit" class="upload-button">Upload</button>
    <ProgressBar />
    <div id="uploadStatus"></div>
    <div id="uploadResult"></div>
</form>

<script>
    import { validateFile, previewFile } from "utils/file-helpers";
    import { ALLOWED_FILE_TYPES, MAX_FILE_SIZE } from "utils/constants";
    import { generateRandomString } from "utils/helpers";

    const dropArea = document.getElementById("dropArea") as HTMLDivElement;
    const pasteArea = document.getElementById("pasteArea") as HTMLDivElement;
    const fileInput = document.getElementById("fileInput") as HTMLInputElement;
    const uploadForm = document.getElementById("uploadForm") as HTMLFormElement;
    const previewContainer = document.getElementById("previewContainer") as HTMLDivElement;
    const progressBar = document.getElementById("progressBar") as HTMLDivElement;
    const progressBarFill = document.getElementById("progressBarFill") as HTMLDivElement;
    const uploadStatus = document.getElementById("uploadStatus") as HTMLDivElement;
    const fileError = document.getElementById("fileError") as HTMLDivElement;

    let selectedFile: File | null = null;

    interface ProgressFetchOptions extends Omit<RequestInit, "body"> {
        onUploadProgress?: (progressEvent: ProgressEvent) => void;
        body?: XMLHttpRequestBodyInit | null;
    }

    async function progressFetch(url: string, options: ProgressFetchOptions): Promise<Response> {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open(options.method || "GET", url);

            for (const key in options.headers) {
                xhr.setRequestHeader(key, options.headers[key]);
            }

            xhr.onload = () => {
                resolve(new Response(xhr.responseText, {
                    status: xhr.status,
                    statusText: xhr.statusText,
                }));
            };

            xhr.onerror = reject;

            if (xhr.upload && options.onUploadProgress) {
                xhr.upload.onprogress = options.onUploadProgress;
            }

            xhr.send(options.body || null);
        });
    }

    function handleFile(files: FileList): void {
        previewContainer.innerHTML = "";
        fileError.textContent = "";

        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const validationResult = validateFile(file, ALLOWED_FILE_TYPES, MAX_FILE_SIZE);
            if (validationResult.valid) {
                previewFile(file, previewContainer);
            } else {
                fileError.textContent = validationResult.error || "Unknown error";
            }
        }
    }

    const handleDragEvent = (e: Event) => {
        e.preventDefault();
        e.stopPropagation();
    
        switch (e.type) {
            case "dragenter":
                dropArea.classList.remove("hidden");
                break;
            case "dragleave":
                if (e.target === dropArea) {
                    dropArea.classList.add("hidden");
                }
                break;
            case "drop":
                dropArea.classList.add("hidden");
                const files = (e as DragEvent).dataTransfer?.files;
                if (files) {
                    const dataTransfer = new DataTransfer();
                    for (let i = 0; i < files.length; i++) {
                        dataTransfer.items.add(files[i]);
                    }

                    fileInput.files = dataTransfer.files;
                    handleFile(files);
                }
                break;
        }
    };
    
    ["dragenter", "dragover", "dragleave", "drop"].forEach(eventType => {
        document.addEventListener(eventType, handleDragEvent as EventListener);
    });

    document.addEventListener("paste", async (e: ClipboardEvent) => {
        e.preventDefault();

        const items = e.clipboardData?.items;
        if (items) {
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf("image") !== -1 || items[i].type.indexOf("video") !== -1) {
                    const file = items[i].getAsFile();
                    if (file) {
                        const validationResult = validateFile(file, ALLOWED_FILE_TYPES, MAX_FILE_SIZE);
                        if (validationResult.valid) {
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(file);
                            const files = dataTransfer.files;
                            if (files) {
                                await uploadFile(files);
                            }
                        } else {
                            fileError.textContent = validationResult.error || "Unknown error";
                        }
                        break;
                    }
                }
            }
        }
    });

    pasteArea.addEventListener("click", () => {
        fileInput.click();
    });

    fileInput.addEventListener("change", (e: Event) => {
        const target = e.target as HTMLInputElement;
        const files = target.files;
        if (files) {
            handleFile(files);
        }
    });

    uploadForm.addEventListener("submit", async (event: Event) => {
        event.preventDefault();
        const files = fileInput.files;
        if (files && files.length > 0) {
            await uploadFile(files);
        } else {
            fileError.textContent = "Please select a valid file to upload.";
        }
    });

    async function uploadFile(files: FileList) {
        if (files.length > 1) {
            let hasImage = false;
            let hasVideo = false;

            for (let i = 0; i < files.length; i++) {
                const fileType = files[i].type;
                if (fileType.startsWith("image/")) {
                    hasImage = true;
                } else if (fileType.startsWith("video/")) {
                    hasVideo = true;
                }
            }

            if (hasVideo && files.length > 1) {
                fileError.textContent = "You cannot upload more than one video at a time.";
                return;
            }

            if (hasVideo && hasImage) {
                fileError.textContent = "You cannot upload videos with images. Please upload videos separately.";
                return;
            }

            if (files.length > 4) {
                fileError.textContent = "You can only upload up to 4 images in an album.";
                return;
            }
        }

        uploadStatus.textContent = "Uploading...";
        progressBar.style.display = "block";
        progressBarFill.style.width = "0%";

        if (files.length === 1) {
            const file = files[0];
            const formData = new FormData();
            formData.append("file", file);

            try {
                const response = await progressFetch("/api/upload", {
                    method: "POST",
                    body: formData,
                    onUploadProgress: (progressEvent) => {
                        if (progressEvent.lengthComputable) {
                            const percentComplete = (progressEvent.loaded / progressEvent.total) * 100;
                            progressBarFill.style.width = percentComplete + "%";
                        }
                    }
                });

                if (response.ok) {
                    const data = await response.json();

                    const storedFiles = localStorage.getItem("uploadedFiles");
                    const files = storedFiles ? JSON.parse(storedFiles) : [];
                    files.push(data);
                    localStorage.setItem("uploadedFiles", JSON.stringify(files));

                    window.location.href = data.link;
                } else {
                    const errorData = await response.json();
                    fileError.textContent = errorData.error || "An error occurred during upload.";
                }
            } catch (error) {
                fileError.textContent = "An error occurred during upload.";
            } finally {
                uploadStatus.textContent = "";
                progressBar.style.display = "none";
            }
        } else {
            const albumId = generateRandomString(8);
            const albumKey = generateRandomString(16);
            const uploadedFiles: any[] = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const formData = new FormData();
                formData.append("file", file);
                formData.append("albumId", albumId);

                try {
                    const response = await progressFetch("/api/upload", {
                        method: "POST",
                        body: formData,
                        onUploadProgress: (progressEvent) => {
                            if (progressEvent.lengthComputable) {
                                const percentComplete = (progressEvent.loaded / progressEvent.total) * 100;
                                progressBarFill.style.width = percentComplete + "%";
                            }
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        uploadedFiles.push(data);
                    } else {
                        const errorData = await response.json();
                        fileError.textContent = errorData.error || "An error occurred during upload.";
                    }
                } catch (error) {
                    fileError.textContent = "An error occurred during upload.";
                }
            }

            const storedAlbums = localStorage.getItem("uploadedAlbums") || "[]";
            const albums = JSON.parse(storedAlbums);
            albums.push({ id: albumId, key: albumKey, files: uploadedFiles });
            localStorage.setItem("uploadedAlbums", JSON.stringify(albums));

            try {
                const response = await fetch(`/api/album/${albumId}`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ id: albumId, key: albumKey, files: uploadedFiles })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error("Error saving album:", error);
            }

            window.location.href = `/a/${albumId}`;
        }
    }
</script>

<style>
    #uploadForm {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 300px;
        margin: 0 auto;
    }

    .upload-button {
        width: 75%;
        margin-top: 0.3rem;
        transition: background-color 0.3s ease;
    }

    .upload-button:hover {
        background-color: #0056b3;
    }

    #dropArea {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    #dropArea:not(.hidden) {
        opacity: 1;
    }

    #dropArea.hidden {
        display: none;
    }

    .drop-message {
        background-color: rgba(255, 255, 255, 0.2);
        border: 2px dashed rgba(255, 255, 255, 0.5);
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        color: white;
        font-size: 24px;
        font-weight: bold;
        transition: all 0.3s ease;
    }

    .drop-message:hover {
        background-color: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.7);
    }

    .icon {
        width: 80px;
        height: 80px;
        margin: 0 auto 20px;
    }

    .icon svg {
        width: 100%;
        height: 100%;
        stroke: white;
    }

    #pasteArea {
        border: 2px dashed #ccc;
        padding: 20px;
        text-align: center;
        cursor: pointer;
        margin-bottom: 1rem;
        transition: all 0.3s ease;
    }

    #pasteArea .preview-item {
        display: inline-block;
        margin: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }

    #pasteArea:hover {
        border-color: #999;
        background-color: rgba(0, 0, 0, 0.05);
    }
</style>
